(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{637:function(t,e,n){"use strict";n.r(e);var a=n(6),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("在使用 Mutex 在给线程/进程间加锁时，需要注意的问题。")]),t._v(" "),n("h2",{attrs:{id:"_1-abandonedmutexexception"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-abandonedmutexexception"}},[t._v("#")]),t._v(" 1 AbandonedMutexException")]),t._v(" "),n("p",[t._v("在使用 "),n("code",[t._v("mutex.WaitOne")]),t._v(" 时，可能抛出异常 AbandonedMutexException 。")]),t._v(" "),n("ul",[n("li",[t._v("发生了什么？\n有一个线程获得了锁，但没有释放锁，则会抛异常，此时数据的完整性可能被破坏。"),n("br"),t._v("\n具体解释见："),n("a",{attrs:{href:"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.abandonedmutexexception",target:"_blank",rel:"noopener noreferrer"}},[t._v("AbandonedMutexException Class (System.Threading) | Microsoft Docs"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("比如：在 WaitOne 之后，进程直接退出，后台线程中的 mutex 可能就还没有释放。")]),t._v(" "),n("ul",[n("li",[t._v("如何处理？\n如果不关心这个异常，可以直接 catch ，继续进行接来下的操作即可。无需再次调用 "),n("code",[t._v("WaitOne")]),t._v("。")])]),t._v(" "),n("div",{staticClass:"language-csharp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-csharp"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        mutex"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("WaitOne")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbandonedMutexException")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 即使捕获到这个异常，此时也已经获得了锁")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    mutex"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("ReleaseMutex")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("ul",[n("li",[t._v("其它内容\n考虑如下场景，运行 run.exe 程序，里面获取了 mutex 锁，没有释放直接退出，再次打开 run.exe ，是不会有 AbandonedMutexException 异常的。\n但如果同时运行两个（多个） run.exe 程序，第一个获取锁之后不释放直接退出，则第二个 run.exe 会捕捉到 AbandonedMutexException 异常。"),n("br"),t._v("\n原因（猜测）："),n("br"),t._v("\n在只有一个 run.exe 进程时，关闭之后，mutex 对应的内核对象随之释放，第二次运行，新建一个全新的 mutex 内核对象；"),n("br"),t._v("\n而当有两个（多个）run.exe 进程时，mutex 对象始终只有一个。")])]),t._v(" "),n("h2",{attrs:{id:"_2-system-applicationexception"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-system-applicationexception"}},[t._v("#")]),t._v(" 2 System.ApplicationException")]),t._v(" "),n("p",[t._v("当 WaitOne 对应的 ReleaseMutex 不在同一线程时，会抛出异常：System.ApplicationException:“从不同步的代码块中调用了对象同步方法。”")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("当出现 ApplicationException 异常时，锁被释放了吗？"),n("br"),t._v("\n没有。只有当调用 WaitOne 的线程被回收之后，才会释放锁，并且下一个 WaitOne 会捕获 AbandonedMutexException 异常。")])]),t._v(" "),n("li",[n("p",[t._v("如何避免\n在 WaitOne 和 ReleaseMutex 之间不要插入 async/await 方法，否则可能带来线程切换。"),n("br"),t._v("\n在 UI 线程调用 WaitOne 和 ReleaseMutex ，之间倒是可以插入 async/await 方法，最后还是会回到 UI 线程，但是，这样 WaitOne 就是在 UI 线程等啊，卡 UI 啊。")])])]),t._v(" "),n("h2",{attrs:{id:"_3-关于-waitone-与-releasemutex-的次数。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-关于-waitone-与-releasemutex-的次数。"}},[t._v("#")]),t._v(" 3 关于 WaitOne 与 ReleaseMutex 的次数。")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("WaitOne 多少次，就要 ReleaseMutex 多少次。")])]),t._v(" "),n("li",[n("p",[t._v("WaitOne 1 次， ReleaseMutex 多次会怎么样?"),n("br"),t._v("\n如果下一个 WaitOne 还没有被调用， ReleaseMutex 多次与一次的效果是一样的，如果有多个 WaitOne 在等待，那 ReleaseMutex 可能会帮其它的 WaitOne 释放锁，具体会不会真的释放，得看时机和运气。")])])]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("更多内容，可以参阅：\n"),n("a",{attrs:{href:"https://walterlv.com/post/mutex-in-dotnet.html",target:"_blank",rel:"noopener noreferrer"}},[t._v(".NET 中使用 Mutex 进行跨越进程边界的同步 - walterlv"),n("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);